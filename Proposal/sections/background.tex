\chapter{Background}
\label{ch:background}

\section{Monolithic Software Architecture}
\label{sec:background:monolith}
The monolithic software architecture is a well-known and the most widely used pattern for Enterprise Applications, which usually are built in three main parts (top to bottom): The client-side user interface (Tier 3), the server-side application (Tier 2) and the persistence layer (Tier 1). The server-side application - \textit{the monolith} - is a single unit and deployed on one application server \cite{infoq}. The software structure, if well defined, is composed of self-contained modules (i.e. software components), where each module consists of a set of functions \cite{HeuristicsAlwis}.
The monolith implements a complex domain model, including all functions, many domain entities and their relationships.
For small applications, this approach works relatively well. They are simple to develop, test and deploy \cite{FunctionalDecompositionHeinrich}. Fast prototyping is supported by the current frameworks and development environments (IDE), which are still oriented around developing single applications \cite{infoq}.
\\
But once they grow in size, they become exceedingly difficult to understand and hard to maintain without reasonable effort \cite{FunctionalDecompositionHeinrich} \cite{ClassificationOfRefactoring}. A complex and large code base prevents a fast addition of new features and makes the application risky and expensive to evolve \cite{TowardsTechnique}.
Alterations to the system, even though they might be small, result in a redeployment of the whole monolith application due to its nature being a single unit \cite{FunctionalDecompositionHeinrich}. Moreover, it is difficult to adopt newer technologies without rewriting the whole application, as monolith are build on a specific technology stack \cite{infoq} \cite{ExtractionMazlami}.\\
Scaling is only possible by duplicating the entire application  - namely \textit{horizontal scaling}. Consequently, large portions of the infrastructure remains unused, if only parts of the application need to be upscaled or even used \cite{EnticeApproach} \cite{MigratingTowardsSurvey}. \\
Chen et al. provide a short résumé:

\vspace*{\fill}

\centering

\textit{"Successful applications
	are always growing in size and will eventually become a
	monstrous monolith after a few years. Once this happens,
	disadvantages of the monolithic architecture will outweigh
	its advantages."} \cite{DataflowDrivenChen}


\vspace*{\fill}


\section{Microservices}
\label{sec:background:microservices}
* gain popularity industy and academia to ovecome shortcoming of monolit /amiri

* scale up, replicated through the cloud / heuristisvs

* alternative way, overcome challenges of monolithic / dataflow
* own its domain model (data, logic, behaviour) /robert
*  relted functionality combine in singel business capability (bounded contexts)
* each ms implements one such capability /robert
*enable traceability between requirements and syste structure --> only one ms has to change and redeployed in case of update /robert

* Definition: an approach for developpn --> FOWLER  / interface

*felexibility of large sclae distributed apps make them better cope wit operation, maintenance, evolution uncertainities --> improves maintenance costs an QuS /meta model

*from scratch: Can be very expensinve and time consuming

*size of s defined by its features it provides /workload based
*effect on performance directly depends on relatioship between its features / workload base

- Definition
- Benefits
- Disadvantages

