

\chapter{State of the Art}
\label{ch:StateOfTheArt}
This chapter outlines the current state of the art regarding microservice identification.  Sec. \ref{sec:StateOfTheArt:LiteratureReview} presents the search strategy and several existing approaches (Table \ref{tab:overviewLiterature}) that deal with the identification of microservices. Thereupon, the approaches are further explained and finally compared on the basis of several criteria.

\section{Literature Review}
\label{sec:StateOfTheArt:LiteratureReview}
The approaches mentioned in table \ref{tab:overviewLiterature} are the result of an extensive literature research which was conducted using the digital libraries IEEE \footnote{http://ieeexplore.ieee.org }, ACM \footnote{http://portal.acm.org} and SpringerLink \footnote{http://www.springerlink.com }. The web search enginge Google Scholar \footnote{http://scholar.google.com} provided further approaches and general information. \cite{FunctionalDecompositionHeinrich} was provided by the supervisor of this thesis and \cite{ServiceCutter} was cited by various approaches, including \cite{interfaceAnalysisBaresi}. The following search string was used:

\begin{centering}
{\itshape
   ["identify" OR "identification" OR "migrating" OR "monolith" OR "decomposition" OR "decompose monolith"
  	OR "decompose"] AND  "microservice"  \\
  	   OR \\  "microservice"  AND ["identification" OR "transformation" OR "refactor"]
}
 
   
\end{centering}

\noindent
Table \ref{tab:overviewLiterature} presents the 8 most promising approaches regarding the criteria mentioned in table //TODO!!!!!!. Now, a short introduction to each approach is given.




\begin{table}[h!]

\centering
     
	
	 \rowcolors{2}{gray!25}{white}
	\begin{tabularx}{\textwidth}{lXXlX}
		\rowcolor{gray!50}
		Link & Titel & Author   & Origin & Search String  \\
		
		\rowcolor{gray!50}
		& & (Year) & & \\
		
		\cite{ExtractionMazlami} & Extraction of Microservices from Monolithic Software Architectures  & G. Matzlami et. al. (2017) & Google Scholar&  {\itshape microservice identification }  \\
		
		
		\cite{ObjectAwareAmiri} & Object-Aware Identification of Microservice & M. J. Amiri (2018) & IEEE & \textit{identification microservices}\\\
		
		\cite{interfaceAnalysisBaresi} & Microservices Identification Through Interface Analysis & L. Baresi et. al. (2017)& SpringerLink & \textit{microservice identification}\\
		
		
		
		 
		 \cite{FunctionalDecompositionHeinrich}& Identifying Microservices Using Functional Decomposition & S. Tyszberowicz et. al. (2018) & \textit{provided} & \textit{n/a} \\
		 
		 \cite{DomainEngineeringMunezero} & Partitioning Microservices: A Domain Engineering Approach & I. J. Munezero et. al. (2018) & ACM & \textit{partition microservices}\\
		 
		 
		 \cite{DataflowDrivenChen} & From Monolith to Microservices: A Dataflow-Driven Approach & R.Chen et. al & IEEE & monolith microservice \\
		 
		\cite{HeuristicsAlwis} & Function-Splitting Heuristics for Discovery of Microservices in Enterprise Systems & A. De Alwis et. al. (2018 )& Google Scholar & identify microservices \\
		
	\cite{ServiceCutter} & 	Service Cutter: A Systematic Approach to Service Decomposition& M. Gysel et. al. (2016) & \cite{interfaceAnalysisBaresi} & \textit{n/a} \\
	
	\end{tabularx}
	\caption{List of authors and approaches}
	\label{tab:overviewLiterature}
\end{table}


\clearpage





\section{Approaches}
\label{sec:stateOfTheArt:approaches}
The following section provides a short introduction in the approaches mentioned in table \ref{tab:overviewLiterature}. Further evaluation and comparison is done in Sec. ???? TODO!!!! \\

\noindent
\textbf{Extraction of Microservices from Monolithic Software Architectures   } \\
The approach presented in \cite{ExtractionMazlami} is a class based extraction model, that uses (meta-)information of a version control system \textit{(VCS)} such as Git\footnote{https://github.com/} to identify microservices. The approach is divided in two phases: The \textit{Construction Phase} and the \textit{Clustering Phase}.
Starting with a given code base, the approach uses three different coupling strategies and the information provided by the \textit{VCS} to transform the monolith into a weighted graph. Here, the nodes represent classes, and the edges have weights according to the chosen coupling strategy. In the second phase, a clustering algorithm determines possible microservices (each cluster is a microservice candidate). \\

\noindent
\textbf{Object-Aware Identification of Microservice  } \\
\cite{ObjectAwareAmiri} identifies microservices from business processes, using the widely known \textit{Business Process and Model Notation (BPMN)}. The approach uses clustering based on structural dependency and data object dependency. The first aspect is extracted from related activities within the business process model. A relation exists, if an edge directly connects a pair of activities or if only gateways are in between. \\
The latter aspect is based on the data object read and writes of each activity. Activities that are directly or indirectly connected and perform write or read operations are more likely to partition into the same microservice. \\


\noindent
\textbf{Microservices Identification Through Interface Analysis   } \\
In \cite{interfaceAnalysisBaresi}, the author proposes an approach that is based on semantic similarity of functionality specified through OpenApi\footnote{https://www.openapis.org/} specifications (OpenApi defines a language-agnostic, standardized and machine-readable interface for RESTful APIs). The similarity depends on a reference vocabulary: each operation of the specification is analysed along with its resources (parameters, return values, complex types) and mapped to a concept of the chosen reference vocabulary. Each mapping has a score, based on a fitness function that uses the collocation of words (called terms) found in the operation and in the concepts. A co-occurrence matrix contains all mappings of possible pairs of terms and concepts. It is maximized to obtain the best mappings. Finally, this approach identifies potential candidate microservices, as fine-grained groups of operations, that are mapped to the same reference concept. \\


\noindent
\textbf{Identifying Microservices Using Functional Decomposition  } \\
The approach presented in \cite{FunctionalDecompositionHeinrich} identifies microservices by functional decomposition of the software requirements, provided as use case specifications. In order to achieve the decomposition, the system is  modelled as a finite set of \textit{system operations} and the system's \textit{state space}. Use cases provide the necessary input data: Verbs found in the use cases serve as \textit{system operations} and nouns correspond to the \textit{state variables} that the operations read or write. The state variables constitute the state space. Relationships between the operations and the variables are store in a relation table, that is visualized as a weighted graph. Finally, the approach uses graph analyse tools to determine clusters, where each cluster is a potential candidate of a microservice that fulfils the criteria of low coupling and high cohesion. \\



\noindent
\textbf{Partitioning Microservices: A Domain Engineering Approach } \\
Munezaro et al. \cite{DomainEngineeringMunezero} propose an approach to identify appropriate microservices using \textit{Domain-driven Design (DDD)} patterns. As a prerequisite, developers define a domain by using ubiquitous language. The domain indicates what the system does, precisely the system responsibilities, and what functionality it must implement. Domain experts define the boundaries of each responsibility and make it as a \textit{business capability}, where a business capability is something that a system does in order to generate value. Each business capability is a microservice. When defining the boundary, the focus is on the relationships among the responsibilities to minimize cross-cutting transactions. \\

\noindent
\textbf{From Monolith to Microservices: A Dataflow-Driven Approach } \\
\cite{DataflowDrivenChen} uses a top-down data flow driven decomposition approach to determine high cohesive and loosely coupled microservices. Before the actual identification process starts, a \textit{Data Flow Diagram (DFD)} needs to be constructed on the users' natural language description of the system to illustrate the detailed data flow. The first step of the approach consist of manually constructing a purified DFD, which focuses on data's semanteme and operations only. Afterwards, the purified DFD is algorithmically transformed into a decomposable DFD which is finally used to extract potential microservice candidates. \\


\noindent
\textbf{Function-Splitting Heuristics for Discovery of Microservices in Enterprise Systems  } \\
\cite{HeuristicsAlwis} is an approach that utilizes heuristics to specify two fundamental areas of microservice discovery: Function splitting based on common object subtypes and functional splitting based on common execution fragments across software. \\
The discovery process consists of two steps: First, the code, database tables and the SQL queries are evaluated to identify business objects and their relationships. Along with a set of given execution call graphs (different sequences of operations; generated though e.g. analysing log data), the information found is passed to the second part of the process. Algorithms processes the call graphs of the legacy system to derive a set of subgraphs and analyse which fragments are related to the same business objects in order to recommend possible microservices. \\

\noindent
\textbf{Service Cutter: A Systematic Approach to Service Decomposition  } \\
Gysel et al. \cite{ServiceCutter} introduce a service decomposition tool based on 16 coupling criteria coming from industry and literature. A coupling criterion is a decision driver to decide whether data, operations or artifacts (generalized under the term \textit{nanoentity}) should or should not be owned and exposed by the same service. Additionally, each criterion has a different score according to its priority.
The input is in form of various \textit{System Specification Artifacts (SSAs)}, such as domain models and use cases.  The tool \textit{Service Cutter} extracts coupling criteria information out of it, that must be prioritised by a user. To analyse and process the coupling criteria, Service Cutter creates a weighted graph. The nodes represent the nanoentities and the weights on and edge is the sum of all scores per criterion, multiplied by a user defined priority. In the end, an exchangeable clustering algorithm identifies potential microservice candidates where each cluster correspond to a high cohesive and loosely coupled service.
 
\section{Comparison} 
\label{sec:stateOfTheArt:comparison}

Table \ref{tab:compareApproaches1} and \ref{tab:compareApproaches2} provide a short description of the identified approaches mentioned above regarding some comparison criteria. The following criteria were used: \textbf{Basis Concept} recaptures the underlying approach of the microservice identification for classification purposes. \textbf{Prerequisites} presents the necessary preconditions for the success of the approach. For example, the approach mentioned in \cite{ExtractionMazlami} cannot be used without meaningful VCS\footnote{Version Control System} data. The \textbf{Input} row describes the type and amount of input that is used realize the approach, i.e. Data Flow Diagrams in \cite{DataflowDrivenChen}. The row \textbf{Tool Support} indicates, whether the approach has been implemented or if other supporting tools are available to simplify the identification of high cohesive and loosely coupled microservices. The \textbf{Degree of human involvement} is part of the comparison, as this thesis aims to reduce the complexity of the service identification while keeping the required amount of expertise and manual tasks on a minimum. As evaluated in Sec.\ref{sec:background:microservices}, defining fine-grained microservices is a key challenge. Therefore, the approaches need to be compared in regard to the \textbf{Granularity of the recommended Microservices}. Some approaches allow an adjustable level of the granularity (e.g. \cite{ExtractionMazlami}), whereas others generate a predefined granularity (e.g. always the most fine-grained microservice candidates \cite{HeuristicsAlwis}). \textbf{Validation} compares how the approaches are validated to strengthen the credibility of the individual results. Each approach might have some drawbacks regarding it's applicability to universal systems, required amount and type of input, user interaction and further expertise. \textbf{Limitations} is meant to point out the identified drawbacks. \\


In the following, each approach is compared against the criteria mentioned above. 


, if necessary, compared against the criteria (only if the information provided in Table \ref{tab:compareApproaches1} and \ref{tab:compareApproaches2} is not sufficient).\\


\afterpage{%
	\clearpage% Flush earlier floats (otherwise order might not be correct)
	\thispagestyle{empty}% empty page style (?)
	\begin{landscape}% Landscape page
		
		
	\begin{threeparttable}[h!]
		
		\centering
		
		
		\rowcolors{2}{gray!25}{white}
		\begin{tabularx}{\linewidth}{XXXXX}
			\rowcolor{gray!50}
			Approach/Criterion & Mazlami et al. \cite{ExtractionMazlami} & Amiri \cite{ObjectAwareAmiri} &  Baresi et al. \cite{interfaceAnalysisBaresi}   & Tyszberowicz et al. \cite{FunctionalDecompositionHeinrich}   \\
			
		
			Basic Concept	& meta-data aided graph clustering & business process oriented graph clustering & semantic similarity of OpenApi specification & functional decomposition of sw requirements \\
			
			 	Prerequisites	& applications with meaningful VCS data & business processes and entities available  & well-defined Api with proper naming & specification of software requirements \\
			
			Input & Source Code and VCS meta data & BPMN business processes with
			data object reads and writes  & reference vocabulary (fitness function), OpenApi specifications & use cases\\
			
			Tool support & prototype available (https://github.com/gmazlami/microserviceExtraction-frontend)
			  & n/a & experimental prototype (https://github.com/mgar riga/decomposer) & use external graph visualize and analyse tools \\
			
			Degree of human involvement & choose amount of clusters that will represent the microservices  & no interaction needed & user defines level of hierachy & manual elimination of synonyms, irrelevant nouns and verbs \\
			
			Granularity of the  recommended Microservices & depends on choosen amount of clusters & depends on iteration of genetic algorithm for convergence of fitness function & depends on choosen hierachy lebel, varies from one to many & depends on size of business capability \\
			
			Validation & experiements using open-source projects with VCS data (200 to 25000 commits, 1000 to 500000 LOC, 5 to 200 authors)  & multiple experiments, results compared with domain experts knowledge  & 452 OpenApi specification, 5 samples compared with results of sw-engineers and \cite{ServiceCutter}& case study, compared to three manual implementations \\
			
			Limitation & need meaningful VCS data and ORM model for its data entities & given weight definitions lack formal explanation    & depends on reference vocabulary and well-defined interfaces & manual revision of operations (nouns) and state variable (verbs) \\
			
		\end{tabularx}
		\caption{Comparison of Approaches, Part I}
	\label{tab:compareApproaches1}
	 
	
	
	\end{threeparttable}
	

	
	\end{landscape}
	\clearpage% Flush page
}

\afterpage{%
	\clearpage% Flush earlier floats (otherwise order might not be correct)
	\thispagestyle{empty}% empty page style (?)
	\begin{landscape}% Landscape page
		
		
		\begin{threeparttable}[h!]
			
			\centering
			
			
			\rowcolors{2}{gray!25}{white}
			\begin{tabularx}{\linewidth}{XXXXX}
				\rowcolor{gray!50}
				Approach/Criterion & Munezero et al. \cite{DomainEngineeringMunezero} & Chen et al. \cite{DataflowDrivenChen} & Alwis et al. \cite{HeuristicsAlwis} & Gysel et al. \cite{ServiceCutter}   \\
				
				
				Basic Concept	& define business capabilities by using domain-driven design patterns & algorithmic identification of microservices using data flows & graph-based identification process using heuristics to describe call graph similarities & service decomposition based on 16 coupling criteria \\
				
				Prerequisites	& domain defined by ubiquitous language& systems's data flows constructen on users' natural langugae description& Log files of legacy system & various System Specification Artifacts (SSAs) in specified format\\
				
				Input & well defined domain model& Data Flow Diagrams (DFD)& Call Graphs, Source Code, System Database& instances of SSAs (e.g. ERM models, use cases) \\
				
				Tool support & n/a & n/a & External tool for generating call graphs & implementation and wiki available\\
				
				Degree of human involvement & domain experts define boundaries for business responsibilities & manual construction of purified DFD& no interaction needed & priorization of coupling criteria \\
				
				Granularity of the  recommended Microservices & depends on the size of the defined business capability & most fine-grained ms candidates in terms of data operations & lowest granularity of sw based on structural and behavioural properties  & n/a\\
				
				Validation & demonstrated on sample domain& two case studies verified against relevant microservice principles and results of \cite{ServiceCutter} & two experiemtns with complex enterprise systems (legacy vs. ms implementation) & validation via implementation and two case studies\\
				
				Limitation & only conceptional approach, requires vast amount of expertise & transforming purified DFD not trivial (identifying same data operations requires expertise)& requires expressive log files to generate call graphs and identify business object relationships& generating SSAs in specified format is work intense  \\
				
			\end{tabularx}
			\caption{Comparison of Approaches, Part II}
			\label{tab:compareApproaches2}
			
			
			
		\end{threeparttable}
		
		
		
	\end{landscape}
	\clearpage% Flush page
}




























