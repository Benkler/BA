

\chapter{State of the Art}
\label{ch:StateOfTheArt}

\section{Literature Review}
\label{sec:StateOfTheArt:LiteratureReview}

\begin{table}[!h]
\centering
     
	
	 \rowcolors{2}{gray!25}{white}
	\begin{tabularx}{\linewidth}{lXXlX}
		\rowcolor{gray!50}
		Link & Titel & Author   & Origin & Search String  \\
		
		\rowcolor{gray!50}
		& & (Year) & & \\
		
		\cite{ExtractionMazlami} & Extraction of Microservices from Monolithic Software Architectures  & G. Matzlami et. al. (2017) & Google Scholar&  {\itshape microservice identification }  \\
		
		
		\cite{ObjectAwareAmiri} & Object-Aware Identification of Microservice & M. J. Amiri (2018) & IEEE & \textit{identification microservices}\\\
		
		\cite{interfaceAnalysisBaresi} & Microservices Identification Through Interface Analysis & L. Baresi et. al. (2017)& google scholar & \textit{microservice identification}\\
		
		
		
		 
		 \cite{FunctionalDecompositionHeinrich}& Identifying Microservices Using Functional Decomposition & S. Tyszberowicz et. al. (2018) & \textit{provided} & \textit{n/a} \\
		 
		 \cite{DomainEngineeringMunezero} & Partitioning Microservices: A Domain Engineering Approach & I. J. Munezero et. al. (2018) & IEEE & \textit{identify microservices}\\
		 
		 
		 \cite{DataflowDrivenChen} & From Monolith to Microservices: A Dataflow-Driven Approach & R.Chen et. al & IEEE & monolith to microservice \\
		 
		\cite{HeuristicsAlwis} & Function-Splitting Heuristics for Discovery of Microservices in Enterprise Systems & A. De Alwis et. al. (2018 )& Google Scholar & identify microservices \\
		
	\cite{ServiceCutter} & 	Service Cutter: A Systematic Approach to Service Decomposition& M. Gysel et. al. (2016) & \cite{interfaceAnalysisBaresi} & \textit{n/a} \\
	\end{tabularx}
	
\end{table}

\pagebreak



\section{Comparison and applicability of the approaches}
\label{sec:StateOfTheArt:ComparisonAndApplicability}
* bedeuted INFO \\
+ beudeted PRO \\
- bedeuted CONTRA \\

\subsection{Extraction of Microservices from Monolithic Software Architectures}
* informal migration patterns exists. Lack of Formal Models \\
* small and recent body of work on how to migrate monolith to MS\\
* clas based extraction model, construct graph, process by clustering algorithm\\
* references Service Cutter (Pros and Cons)\\
* 2 phases: Construction (monolith to graph), clustering (decompose graph to cluster)\\
* starts with code base/repo from VCS\\
* each class is a node, edges have weights according to coupling strategy (classes that are not coupled are discarded)\\
* Logical Coupling Strategy(LC): Single Responsibility principle (Software has only one reason to change), enforce strong module boundaries (concept of MS) --> developers only make changes to the module (found in Change History, Class Files changed together belong togehter) ==> Weight is : for each pair of class look how often they changed together\\
* Semantic Coupling Strategy(SC): each MS correspond to one bounded context (DDD) from domain, examine contents/semantics of source code, term-frequency invese-documents-frequency method (tf-idf), compute relation of two classes regarding domain concepts\\
* tf-idf: Compute scalar vector for each class and compute cosine similarity between pairwise distinct classes\\
* tf-idf: Tokenize class, set of words, filter stop words, compare two classes regarding their common words with tf-idf formula\\
* Main Concern: Well organized teams, cross-functional but also reduce communication overhead to external teams while maximize internal\\
* Contributor Coupling (CC): team/orga info used to recover relationship among sw artifacts ==> Ownership architecture read from VSC history by identifying how many developers worked on the same pair of classes (weight!)\\


* CLustering Algo: Invert weights to favor edges  with heigh weight, Kruskal for MST (calculate remaining edges), sort edges, reverse list, delete first element (originally lowest weight; now first in the list), in each iteration step: DFS(Depth-First) on edgesMST returns number of partitions, iterate and delete while n<nGiven
*Reduce Cluster: after n cluster were formed, method reduceClusters splits up unusually large clusters (due to language and framework, special classes may have extraordinary high coupling) --> Delete those classes until size of node (numbe rof classes seems to be appropriate)
------------------------------------\\


+ algorithmic recommendation of ms candidates implemented in web-based prototype\\
+ unites traditional decomposition techniques and microservice extraction approaches/design principles\\
+ algorithm uses 3 different coupling strategies: Can be combined for better results\\
+ performance of algortihm was satisfying according to author
+ shows significant team size reduction (less than half), given that alls contributirs for given cluster work on a MS
+ no work in advance!!!!

---------------------------------------\\


- rely on (meta-)data extracted from codebase\\
- needs VCS (proper change history)\\
- needs ORM model that models data entities as ordinary classes
- 2 (independent) changes in one commit destroy SRP\\
- SW must have gone through evolution process for LC\\
- Naming of class, methods, attributes needs to reflect domain language to make tf-idf possible\\
- Contributor Coupling: requires more developers\\
- Reduce Clusters: Useful to delete those classes? wat if this is core of application that belongs together
- nPart is given by user: What is the right granularity?\\

--------------------------------------\\
*Conclusion: Beta implementation existing, paper is precise in usage, master-thesis exists (LINK!!!)with detailed information, easy algorithms, good performance, \\
* No Information about right n, not domain oriented, ORM necessary,
BUT: Not applicable to CoCoME as VCS history, software evolution, several contributor necessary



\subsection{Partitioning Microservices:A Domain ENgineering Approach}

* One BusinessCapability determines one MS, based on domain engineering
* Business Capability: Something hat a business does;combined as functionality that have something in common (instead of usin collections of data entities and CRUD operations in them)
* Paper states: Developers struggle to define granulaity of business capability (too small => Communication overhead, to large: heavyweight SOA)
* Appropriate MS size determined by component boundaries
* DDD: Choosing appropriate boundary. MAIN GOAL: systematically group requirements in domain model and implement code  of that
* Design Domain model with sub-domains (each sub-domain has one to more bounded contexts)
(* Sub-Domain is problem space, bounded.context is solution space and maps software artifacts to sub-domains ==> Info aus Internet)
* DDD Patterns: Context Map/Counded Contexts (makes explicit boundaries between domains,), Aggregates (logical boundaries for cluster of domain objects that change during one transaction, ensure consistency among parallel operations that are considered to be one unit in reagrd to change), Ubiquitous Language (ensures that impementation uses the same terms as business), Separation of Entities and Value types (Entities are Objects of DDD, Not all Objects need to be entitites, for value objects identity is not necessary))
* MS should be autonomous (changes not affecting others): One bounded context is one MS (ore more if fine grained needed, BUT never on C in different MS)
* Approach: Defined domain and ubiquitous language ar prerequisites, split into sb domains if domain is too wide, find boundary of each responsibility, make it as business capability (focus on relationship among different services), each capability is a MS, find out relationships between services with domain model and reconfigure if necessary (too many dependencies)


--------------------------------------------\\


+uses DDD. Many papers and experience reports state that this is the way to gto


---------------------------------------------\\

- draw the boundaries is the ky task and requires domain experts
- requires well defined domain, pre-existing ubiquitous language
- "Find the boundary of each responsibility and make it as a business capability" ==> But how? Requires DOmain experts
- Procedure is not concise at all and only explains approach on a top level (half a page)
- Does not define how procedure analyses "loose coupling possible"
- how break down in subdomains?
- uses brainstorming and interaction wit domain experts to identify and define parts of the microservice


---------------------------------------------\\


