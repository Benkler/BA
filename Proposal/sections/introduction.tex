
\chapter{Introduction}
\label{ch:Introduction}
The monolithic software architecture is the traditional pattern to design software, where functionality is bundled in one single, large application \cite{DataflowDrivenChen}. Although monoliths have their strength, like fast development and simple deployment, they become an obstacle when they grow in size and become more complex \cite{infoq}. Incomprehensible code structure makes it difficult to add functionality, fix bugs and enable new software engineering approaches like Continuous Delivery and Continuous Deployment. 
Besides, the rise of cloud computing demands a new architecture that can fully exploit the rich set of features given by the cloud infrastructure \cite{MigratingCloud}. \\
Microservice Architecture is about to become a promising alternative to overcome the shortcomings of centralized, monolithic architectures. Inspired by service-oriented computing, microservices gain popularity in both, academia and industry \cite{ObjectAwareAmiri}. Benefits like the increase of agility, resilience or scalability \cite{FunctionalDecompositionHeinrich}, the ability to use different technology stacks and independent deployment \cite{interfaceAnalysisBaresi}, and the efficient resource utilization in cloud environments \cite{MigratingCloud} explain, why big companies like Google, Netflix, Amazon, eBay \cite{DataflowDrivenChen} and Uber \cite{FunctionalDecompositionHeinrich} migrated their monolithic architectures to microservice-based applications. \\
This thesis describes the current state of the art regarding microservices extraction and provides a systematic approach to decompose a (legacy) application into microservices.


\section{Motivation}
\label{sec:Introduction:Motivation}
Monolithic software applications develop over time and become more and more complex. The software structure is highly coupled and hard to maintain \cite{MigratingTowardsSurvey}. To tackle this issues, software engineers started to decompose their system into modules and provide the functionality over the network as Web Services \cite{ServiceCutter}. The so-called \textit{Service-oriented Architecture} (SOA) provides logical boundaries between the different software modules to address the design challenge of distributed systems. Nevertheless, Baresi et. al state that the boundaries between modules in SOA are too flexible and the application results in "a big ball of mud" \cite{interfaceAnalysisBaresi}. Microservices make these boundaries physical as each service runs in its own process and only communicates with other services through well-defined lightweight mechanisms like REST \cite{FunctionalDecompositionHeinrich}. Chen et al. consider the microservice architecture as a particular approach for SOA \cite{DataflowDrivenChen}. Others look at it as an evolution of SOA with differences in service reuse \cite{interfaceAnalysisBaresi} or consider it to be the "contemporary incarnation of SOA" combined with modern software engineering practices like continuous deployment \cite{ServiceCutter}. There is no consensus about the relationship between microservices and SOA, but clearly, SOA paved the way for the rise of the microservice pattern.\\
The microservice architectural style has many advantages over the monolithic style. Sec.\ref{sec:background:microservices} elaborates the main aspects of microservices, including several benefits. Netflix, for instance, is able to cope with one billion calls a day to its video streaming API, by migrating their monolithic system to a high flexible, maintainable and scalable microservice architecture \cite{DataflowDrivenChen}. Consequently, moving existing applications to a microservice landscape is a hot topic in academia and industry \cite{ObjectAwareAmiri}. \\
Nevertheless, decomposing a system in loosely coupled, fine-grained and independent microservices is a time consuming task that requires tedious manual effort \cite{ServiceCutter} and is technically cumbersome \cite{HeuristicsAlwis}. So far, it is done mainly intuitively and relies on the experience of software architects and system designers. Hence, a formal approach to identify microservices is required. This thesis intends to describe an approach to systematically decompose a monolithic system into loosely coupled, but high cohesive fine-grained microservices. 


\section{Problem Statement}
\label{sec:Introduction:ProblemStatement}

*one of todays problem in designin ms is to decompose a system into lc, hc and fine grained microservices \cite{ObjectAwareAmiri}
* challenging task because if interconnected functionality --> Problem know as microservice identification /amiri
* microservice-oriented decompositin challenging and complex task, crucial and prerequisite role in devel microservice-based software systems /dataflow
* address challnge and reduce complexity, we nee appproach /dataflow

*how effecively decompose monolithic application in suite of small ms, process usually ba hand /dataflow

* tradeoff between size an number of ms \cite{interfaceAnalysisBaresi}

* in theory many benefits, but manual and complex decompostiton process prevent it from achieving those benefits --> Consequencetly we need more effective decomposition / dataflow

* key challenge: extraction of microservices from existing monolithic code base /mazlami
* informal migration patterns, lack of formak models and automated tool support /mazlami
*identifying components of monolithic applcation that can beturnen in ms is common problem, tedious manual effort, heavily relies ib experience, know hw id erperfts performing the extractrion /mazlami

*tackling complexity of large apps by decomposing them into small pieces, each component resides within its own bounded context /robert
* performed intuitively but provide inapropriate partition into services and getting service boundaries wrong can be costly

* identification of "proper" ms not only aims to partition the system to ease maintenacne, but also defines how system will be abler to evolve and scale /interface

*ambiguity of optimum size, cenceptual appriach is necessary n/domain engineering

*finding tge optimal microservice boundarues (granularity) key design decision --> Influences QoS of ms app at runtime /meta-modelling
* lack of systematic approaches that model ms design decision / meta model

*finding right service granularity to fullyx levergae benefits / classification approach

* mainly solution proposals follow by experience reports and opinion papers --> field is not mature yet /classification approach

\section{Challenges}
\label{sec:Introduction:Challenges}

*highly interconnected, challenging task to decompose system intoa ppropriare ms / objet-aware

* preserve coherent features (minimize cross talk) / heurisstics
*restructuring technically cumbersome, tedious search, identifixcation of suitable parts, program code rewrites /heuristics
* costly, error prone, millions LOCm multitude of functional dependecies across modules and software packages /heur
*achieving high scala, availa, low system latencies through the cloud while atrtaining hc, lc between sw  components /heur
*abstent of sound evaluation method aggravate challenges /heur

* big challenge: Find appropriate partition of sytem into microservices /robert
* ms architecture can significantly affect performance
* microservice granularity/number of ms influence QoS /robert

*Finding adequate granularity/cohesiveness of microservices /interface
* tradeoff between size and numbe rof ms /interface


\section{Thesis Outline}
\label{sec_Introduction:ThesisOutline}













\section{Stichpunkte}

\subsection{Approaches}
* \cite{ObjectAwareAmiri}: Object aware,identification from business processes using structural dependency and data object dependency\\
* \cite{ServiceCutter}: Service Cutter, service decomposition based on 16 coupling criteria extracted from literature and industry experience
\cite{interfaceAnalysisBaresi}: interface Analysis,  "automated process for identifying candidate ms my means of lightweight, domain.aghnostic semantic analysis of the concepts in input sepecification with regard ti a reference vocabulary" \\
\cite{FunctionalDecompositionHeinrich} : Functional decomp, systematic approach to identify ms in design phase by identifying relationships between required sytem operations and state variable that ops read/write, visualized in Graph and the clustering\\
\cite{DataflowDrivenChen}: Dataflow-driven, Top down dataflow-driven decomposition algorithm, purified dataflow-driven mechanism \\
\cite{DomainEngineeringMunezero}: Domain Engineering, methodology that uses DDD patterns to partition ms by respecting ms architecture design and characteristics \\
\cite{ExtractionMazlami}: Extractio of Microservices: Graph-based clustering approach with three different coupling strategies that rely on (meta-) information from monolithic code bases (VCS)

\cite{HeuristicsAlwis}: Heuristics, find consumer-oriented parts of enterprise systems that could be re-engineered as ms



\subsection{General Annotations}
* Several companies recentyl migrated to MS like Netflix, Amaozn, Uber
* not many approaches and identified approaches are not mature\\
* many use clustering \\
* based on code inspection, models... various approaches
* use chapter "Supporting Definitions"\\
* Fowler (widely adopted definition): an approach for developing a single application as a suite of small services, each running in its own process and communicationg with lightweight mechanisms, often a RESTful API. \\
* \cite{interfaceAnalysisBaresi}: nmot fully migrate application to ms, preserve monolithic structure and only replicate certain components... \\
Decomposition Approaches by (according to \cite{FunctionalDecompositionHeinrich}): \\
*Usecases(service that is responsible for particular action) 
*verbs (service that is responsible for particular action)
*nouns/resources (service responsible for all operations on entities/resources of a given type)
* business capability: Something that a business does in order to generate valu
* domain-driven design sub-domain (business splitted in different sub-domains) --> Seems to be most common approach


\subsection{Object-aware Identification}
\cite{ObjectAwareAmiri} \\
*Microservices:\\
*MS architectural style inspired by service-oriented computing \\
*cohesive and loosely coupled components, implement business capabilities (each service one capability)\\
* gain popularity in academia and inudtrsy\\
*overcomeshortcomings of centralized, monolithic architectures\\
* single app as suite off small services\\
* communication via leigthweight  mechanisms\\
* 3 principles: \\
* i)Bounded contexts(focused on business capabilities, related functionality implemented in one capability and implemented in one service)\\
* ii)  Size(if servize too large, split up, maintaining focus on providing one business capability only in one service)\\
* iii) Independence( loose coupling and high cohesion)\\
* --> encourages lossely... as each ms operates mostly independent of others \\ 
* independet collection of highly inter-related activities \\

Challenges:\\
* decompose system in cohesive lossely couped, fine-grained MS \\
* done intuitively by experience of system archjitects/Domain experts\\
* functionalities highly interconnected\\
* Problem well known \\

\subsection{Service Cutter}
\cite{ServiceCutter}

Microservice:\\
*important to split distributed systems in lc/hc units\\
*autonomous, network-accessible services.\\
* functional decomposition not new (1972 D.L. Parnas " Ont the Criteria to be used in Decomposing Systems into Modules)\\
* Allow developers to chose most appropriate technology for each particular business problem\\
* MS is "contemporary incarnation of SOA" combined with modern sw engineering practices like continous/idependetnt deployment\\
* decomposition og monolith in services not fully understood ("very much of an art")\\

Motivation: \\
* SW became more complex, sw engineers  started to distribute modules/functionality over network (Web Services)\\
* SOA tackled design challenge of distributed systems\\
* requirements-driven, repeatable and scalable service decomposition method (supported and partially automated by tools) does not exist\\
* use DDD: services derived from bounded contexts are aligned to domain model boundaries and team organization structures \\
* service accessesd remotely through invocation interface\\

Challenges:\\
* loosley coupled and highly cohesive services crucial for maintainability/scalability of software \\
* Not only DDD but also stakeholder requirements: Architecturally significant requirements (sw quality attributes) \\
* Non-functional requirements of sw is key aspect of analysis and design\\


\subsection{Microservice Identification Interface Analysis}
\cite{interfaceAnalysisBaresi}

General: \\
* MS evolution of SOA but differences: service reuse less; instead of reusing existing ms for new tasks they should be small enough to rapidly implement new one that can coexists, evolve, replace the previous one\\

Microservice:\\
* ms style: suite of small, autonomous, conversational services \\
* contrary to monoliths: independent deployability(scalability, using different technology stacks) \\
* boundaries between software module in tradiditonal services (SOA) often too flexible --> "big balls of mud" --> MS make boundaries physical\\
* partition ease system maintenance  and defines hgow system is able to evolve and scale \\



Motivation:\\
*overcome shortcomings of centralized monolithic architecture (deployed as a big chunk)\\
* definition of granularity level and trade-off between soze and number of MS is still blurred\\

Challenges: \\
* finding right granularity/cohesiveness (when starting or transforming project)\\
* identification extraordinary affects how system will be able to evolve --> define proper services is key challenge\\

\subsection{Functional Decompositions}
\cite{FunctionalDecompositionHeinrich}\\

General:\\


Microservices: \\
* rising fast, many companies use it to structure their systems\\
* usually defined intuitively based on experience of designers\\
*advantages: scalability (thus resillience), enhanced performance\\
* inteact via messages using standard data formats and protocols, publish interfaces using well defined lightweight mechanisms such as REST\\
* each microservice has own domain model (data, logic, behaviour), related functionality combined in one business capability (= bounded context), one MS implements capability (more if too big)\\
*tackles complexity of large application by decomposition in small pieces (each in own bounded context)\\
* architecture enable traceability between requirements and system structure --> Only 1 ms needs to be\\ changed/redeployed (overcome shortcomings of monoliths: Deployment easy but everything deployed to a server making changes impact whole application --> redeploy whole app)\\
* two main advantages: functional decomposition, decentralised governance\\
 



Challenges: \\
* find approppriate partition of system --> architecture can significatnly affects performance of system (intra-service calls?) \\
* lack of systematic approaches \\
* hardly any guidelines on what is "a good size" of ms --> Differs from system to system according to research\\
* two concepts for DB\\
* i) Share nothing: Each ms has own db --> Higher speed, horizontal scalability, but price of data consistency (only evenutal consistency)\\
*ii)"microservice is not an island" --> share DB but price of less Independence\\


\subsection{Dataflow-Driven Approach}
\cite{DataflowDrivenChen} \\

General: \\
* Monolith Strength: simple to develop, test, deply, scale. But: Grow in size --> monstrous monolithic architecture, complex/incomprehensible code structure, hold back bug fixes, slow down development, obtsacle for CD\\
* particular approach for SOA but no consensus on relationship of ms and SOA \\
* Advantages  accepted in academia and industry\\
* Advantages: Netflix can deal with billion calls every day by streaming API in ms structure\\
* decomposition process represented by Y-Axix of scaling cube\\
* decomposition by business capability and by domain-.driven design sub domain (abstract patterns, require human involvement); by verb/use cases or nouns/resources (easier to realize automation as lonmg as criteria have been predefined)\\
* Service cutter lack objectivity: Scoring the edge of the graph\\
*SOA: Services coarse-grained (vs. fine grained), decomposition aims at selecting the optimal composed service from all possible service combinations regarding quality requirements --> Bottom Up (vs. MS decomposition is top-down partition, then bottom-up integration)\\

Microservices: \\
* multiple small-scale and independently deployable ms\\
* design time features: Coupling between ms \\
*runtime feature: scalability against changing workload\\
* three design time principles:\\
* i) Fine grain and focus: small, autonomous as main characteristics, each ms does "one thing well"\\
* ii) High cohesion/loose coupling: ms implement relatively independent piece of business logic (hc), microservice should barely depend on other (lc) \\
*iii) Neutral devel. technology, services should be deployable as individual applications with own delivery pipeline \\


Challenges:\\
* ms not panacea, main issue is effectively decompose a monolithic application \\
* commonly manual decomposition process prevent practice for achieving those benefits \\



\subsection{Domain Engineering approach}
\cite{DomainEngineeringMunezero} \\

General:\\
* No guidelines for designing right microservice regaqrdin scope/size \\

Microservice:\\
* ability to make rapid functional changes (compared to monolith)\\
* Issues: integration between communications of applications, complexities arising from creating distributed system (testing, deployment, increased memory consumption)\\
* no common size for all services --> different sizes possible\\


Challenges: \\
*determining th right size of business capability \\
* too fine-grained services can cause inefficiency (high amount of interactions to fulfil one request)\\

\subsection{Extraction from Monolithic software architecture}
\cite{ExtractionMazlami} \\


General:\\
* mobile computing, cloud computing infrastructure, DevOps, elastic computer --> MS driven by there developments\\
* Service Cutter: no means of mining/constructing necessary structure information of monolith --> relies on user to provide sw-artifacts in specific model\\
*Single Responsibility Principle: sw should only have one reason to change --> ms has to follow this principle\\

Microservice:\\
* half the team size\\
* more flexible horizontal scaling in IaaS environment\\
* dedicated to relatively narrow and concise task\\


Challenges:\\
*key challenge: Extracting ms from existing codebases (migration of monolith)\\
* tedious manual effort for analysis of many dimensions of software\\
* tool support and automation is not satisfactory\\
* good part of efforts in ms research is only conceptual \\

\subsection{Function Splitting Heurisitcs}
\cite{HeuristicsAlwis} \\

General: \\
*SOA: services include all logical related operations
*MS: fine-grained components with individual operations


Microservices:\\
* availability, processing efficiency,\\
* distributed system allows scalability and availability as deployed in different containers (dynamic de-allocation of ressources on demand) --> Load balancing\\
* circuit breaker: redirection to another ms instance if no answer after certain time\\
* 

Challenges:\\
*restructuring enterprise systems (large compley, contain complex business processes encoded in application logic) is technically cumbersome \\
* requires tedious search, identification of suitable parts to restructure, program code rewrites --> Costly and error prone (because of millions of LOC)\\
* studies reveal that success rate of re-modularisation techniques especially for large system remain low\\

*-----------------------Approaches finished here----------------------------\\

\subsection{Migrating web Applications to Clouds with Microservice Architectures}
\cite{MigratingCloud}

General: \\
*Cloud Computing advanced, rich set of features in cloud applications, low cost, low threshold\\
* Before: CLient server pattern for old web applications\\

Microservices:\\
* organized around business capability with borad-stack modules for achieving the business (UI, Business Logic, persistent storage)\\
*encapsulated with firm modle boundary --> Independan\\t
* decentralizes transaction and datastorage (own  managing)\\
* collaborating with other services to accomplish  desired business capability\\


Challenges:\\
*need extensive support for infrastructure automation techniques --> Suitable on well infrastructure supported cloud environment\\

\subsection{Entice approach}
\cite{EnticeApproach} \\

General:\\
*Cloud Computing enabled elastic and on-deman service --> achieve more efficient resource utilisation/quicker response to varying application loads\\
* Large scale service oriented applications (monolith) mostly inelastic\\
*user only need some of the offered functionality: Still ned to host complete monolithic service --> Rest not needed and therefore large amount of VM ressources left unused\\


Microservices:\\
*Decomposing large services open towards elasticity\\
* single,well defined functionality  offered by a particular VM --> Image can be optimised to host this functionality\\

\subsection{A systematic Mapping Study in Microservice Architecture}
\cite{SystematicMappingStudyMicroservice} \\

General:\\
*(2016) "microservices architectural style research is still in its infancy" !!!!!!\\

Microservices:\\
*"the minimal independent process that acts via messaging"\\
* increase in agility, developer productivity, resiliencem scalability....\\


Challenges:\\
*Communication/Integration: finding right communication strategy is vital (protocol, response time expectations, timeouts)\\
* Service Discovery: Services need to discover each other, needs standard/consistens process to announce themselves, specify how API gateways are configured\\
*Performance: ms adds more communication between different services, one single business functional requirement could need several service calls --> End User experience endagerd --> Data sharing/synchrnisation necessary\\
* Fault tolerance: Partial failure recovery, cloud environment might crash (IaaS failure)\\
*Security: Communication created trust relationships --> user needs to be identified in all chains of a service communication (OAuth as solution)\\
*Tracing/Loggin: Distributed tracing necessary to track chain of service calls, logging vital for debugging purposes --> Needs careful design of central logging/Aggregation system\\
*Application Performance Monitoring: measuring individual ms\\
*Deployment operations: deployment/scaling fundamental infrastructure concerns --> selecting right platform/orchestration tools is fundamental\\


\subsection{Migrating towards Microservice Architectures: Survey}
\cite{MigratingTowardsSurvey} \\

General:\\
* legacy sw: highly coupled, hard to maintain\\
*industrial survey: roughly 28 months for migration --> Costly\\
* shows that most industrial develloper get inforamtion about the old system of source code and textual/architectural documents to better understand the pre-existing system and to be able to architect a new one\\
* it is significant to have a "crystal clear understanding of the domain of the system in order to identify bounded contexts properly"\\
*Main driver to mirgate: New functionality, long time to release new features, hard to maintain, side effects, low productivity of developers, hard to test, developers interfering with each other\\


Microservices:\\
*flexible/evolvable architecture\\


Challenges:\\
*Many technical challenges: Infrastructure automation distribute debuggin\\
*Organizational challenges: creation of cross functional teams\\


\subsection{Infoq: Decomposing applications}
\cite{infoq} \\


General: \\
* Small services is not the main goal! Decompose system  into services to solve problems of monolithic architecture is main goal --> Services can vary in size\\
* Call MS lightweight or fine-grained SOA\\
* solves problems that many organizations suffer from\\
* Application, several components with good mopdular design (domain model) but deployed as a monolith! --> simple to develop (IDEs are oriented arounf developing single applications), easy to test\\
* BUT: Becomes  unwieldly for complex applications, difficult to adopt new technology without rewriting entire application --> Does not scale to support large long-lived applications\\
* SCALE CUBE: \\
* X-axis: mutltiple identical copies of app behind load balancer --> improve capacity/availability\\
* Z-Axis: Each server runs identical copy (similar to X), but each serve ronly responsible for subset of data --> Component in systems responsible for routing request to servers\\
* --> Z and X improve applications's capacity/availability but do not solve problems of increasing development and application complexitiy --> Y\\
* Y-Axis: functional decomposition, Z-Axis splits similar things, Y-Axis scaling splits different things\\
* API Gateway: No talking directly to service, API Gateway in between that provides coarse grained API for CLients\\
* Inter-Service Communication:\\
* i) synchronous HTTP-bases: simple, familiar, firewall friendly, does not support other patterns like publish/subscribe, servers must be simultaneous available, HTTP client need to know host/prt of server\\
*ii)asynchronous AMQP-based message broker: decouples message producers and consumers, broker handles conversation, broker another moving part\\


Monolith: \\
* Commonly used pattern for enterprise application, works good for small applications: testing developing deploying relatively simple\\
* For large/complex apps, monolithic architecture becomes  obstacle --> Migrate to MS\\

Database: \\
* individual best-fitting database for each service, service needs ACID-transactions --> relational, social media --> graph base\\
* new Problem: Handle requests that access data owned by mutliple services (approaches are RPC--> increases response ime, reduces availability as other service must be available too; other approach is store copy -->consistency problems)\\

Microservices:\\
* small code base does not slow down IDE, makes developers more productive\\
* services typically start a lot faster than monolith\\
* independent deployment: change for local change do not need coordination with other developers	\\
* each service scaled independently: X-axis clonin and z-axix partitioning\\
* service deployed on best suitable hardware\\
* easier to scale development: organize development around mutliple small two pizza teams\\
*improves fault isolation\\
* eliminates any long-term commitment to a techn ology stack\\


Challenges: \\
* additional complexitiy of creating a distributed system\\
* inter-process communication required\\
* IDE/other devel. tools currently still focused on building monoliths\\
* operational complexity, many more moving parts (inst6ances of services)\\
* features spanning mutliple services require careful coordination\\
* WHEN to use this architecture: first version  of application does not have problems ob monolith --> MS slows down development --> Start upds need to deliver fast results\\
* Granularity on APIs too fin-grained --> results in many required service calls --> Latency for clients (solution API Gateway)\\

\subsection{From Monolith To Microservices Classification}
\cite{ClassificationOfRefactoring} \\

General:\\
*high costs/effor for refactoring\\
* high effort to adapt newer and beter technologies, changing initial desgin choices later nearly impossible \\
* need to duplicate monolith in order to scale --> inefficient\\
* refactoring: extend lifetime of existing software product; code level vs architectural refactoring\\
*service Cutter as "general purpose" approach --> most mature tool support, most strucured and generally applicable way to decompose tool support\\


Microservices:\\
* more agile flow of development and operaions (referred as DevOps)\\


Challenges:\\
*finding right service granularity to fully leverage advantages\\
* ms from scratch OR refactorin is vey expensive and time consuming\\


\subsection{Toward understanding and evolution}
\cite{TowardsUnderstandingEvolution} \\

General:\\
*monolith  does many things and has many responsibilities \\
* ms is fine-graines SOA\\
* SRP: each module, subsystem, class, method should not have more than one reason to change\\
*parts can be migrated directly to ms, other parts need to be refactored to make code more modular\\

Microservices:\\




Challenges:\\
* Distribute legacy artifacts into ms not trivial: lack of sesign and documentation, \\
* absent reasoning on oroginal design and architecture decisions\\ 

\subsection{Workload-bases Clustering}
\cite{WorkloadbasedClustering} \\

General: \\

Microservices: \\
*size of MS directly defined by its feautures\\
* several metrics: LOC, able to rewrite it in 6 weeks,  two pizza team per service --> no quality attributes!\\
*Moving features to other services directly inacts performance/scalability:  Smllaer services -> more scalability of system; \\
* performanace decreases when splitting up --> significant communication overhead \\
* merging results in loss of scalabiity\\
* --> Optimize performance vs. scalability by modigying placement of features (= chunk of functionality that delivers busines value)\\


Challenges:\\


\subsection{Architectural Meta-Modelling}
\cite{ArchitecturalMetaModelling}


General:\\
*First class object: Object passed to function or as return value  or  allocated to variable\\
*general lack of systematic approaches that model ms design decisions, including deciding the optimal microservice boundaries\\

Microservices:\\
*isolated fine-grained business functionalities that act through standardized interfaces\\
*rapidly increasing: Netflix, Amazon, Uber\\
* Isolating business functionalities aisma at enhancing the autonomy, replaceability of individual microservice\\
* enhances decentralised governance\\



Challenges:\\



